# PR Governance: enforce labels, milestone, and title rules.
# Uses pull_request (not pull_request_target): we only READ PR metadata via API,
# never checkout or run PR code. Safe for forks; no untrusted code execution.
name: pr-governance

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  pr-governance:
    name: pr-governance
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    steps:
      - name: Validate PR governance
        uses: actions/github-script@v7
        with:
          script: |
            // Fetch fresh PR data (payload may be stale on re-run)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });
            const title = pr.title || '';
            const labels = (pr.labels || []).map(l => l.name);
            const milestone = pr.milestone ? pr.milestone.title : null;

            const PROVENANCE = ['from-composer', 'from-codex', 'from-human'];
            const titleBad = /\[from-(composer|codex|human)\]/i.test(title);
            const provenanceLabels = labels.filter(l => PROVENANCE.includes(l));
            const typeLabels = labels.filter(l => l.startsWith('type:'));
            const areaLabels = labels.filter(l => l.startsWith('area:'));

            const errors = [];

            if (titleBad) {
              errors.push('TITLE: PR title must NOT contain [from-composer], [from-codex], or [from-human]. Provenance is label-only.');
            }
            if (provenanceLabels.length !== 1) {
              errors.push(`PROVENANCE: Expected exactly 1 provenance label; found ${provenanceLabels.length}. Allowed: ${PROVENANCE.join(', ')}. Current: ${provenanceLabels.join(', ') || '(none)'}`);
            }
            if (typeLabels.length !== 1) {
              errors.push(`TYPE: Expected exactly 1 type:* label; found ${typeLabels.length}. Examples: type:feat, type:fix, type:chore, type:docs, type:refactor, type:test. Current: ${typeLabels.join(', ') || '(none)'}`);
            }
            if (areaLabels.length < 1) {
              errors.push(`AREA: Expected at least 1 area:* label; found ${areaLabels.length}. Examples: area:engine, area:dr, area:release, area:infra, area:providers, area:docs (docs-only), area:unknown (fallback). Current: ${areaLabels.join(', ') || '(none)'}`);
            }
            const nonDocsAreas = areaLabels.filter(l => !['area:docs', 'area:unknown'].includes(l));
            if (areaLabels.includes('area:docs') && nonDocsAreas.length > 0) {
              errors.push('AREA: area:docs is docs-only and must not be used as a fallback when another specific area:* label exists.');
            }
            if (areaLabels.includes('area:unknown') && areaLabels.length > 1) {
              errors.push('AREA: area:unknown is fallback-only; remove it when a specific area:* label is present.');
            }
            if (!milestone) {
              errors.push('MILESTONE: PR must have a milestone set (roadmap or bucket: Infra & Tooling, Docs & Governance, Backlog Cleanup).');
            }

            if (errors.length > 0) {
              core.setFailed([
                'PR Governance check FAILED:',
                '',
                ...errors,
                '',
                'Fix: Add missing labels and/or milestone in the PR sidebar, or remove [from-*] from the title.',
              ].join('\n'));
            } else {
              core.info('PR Governance: PASS');
            }
