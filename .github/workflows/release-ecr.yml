name: release-ecr

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag (defaults to commit SHA)"
        required: false
        default: ""
      publish_release:
        description: "Publish a GitHub release from this run"
        required: false
        default: "false"
      release_tag:
        description: "Release tag to publish (defaults to image_tag/commit SHA)"
        required: false
        default: ""
      release_kind:
        description: "Release kind for body validation (product|milestone)"
        required: false
        default: "product"
        type: choice
        options:
          - product
          - milestone
      release_tier:
        description: "Release tier for product releases (major|minor|patch|auto)"
        required: false
        default: "minor"
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
      semver_level:
        description: "SemVer level for product releases (auto|major|minor|patch)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
      major:
        description: "Force major template enforcement"
        required: false
        default: false
        type: boolean
      release_title:
        description: "Release title (defaults to SignalCraft <tag>)"
        required: false
        default: ""
      release_body:
        description: "Release body markdown (validated before publish)"
        required: false
        default: ""
      dev_mode:
        description: "Allow non-digest IMAGE_REF for explicit dev-only releases (true|false)"
        required: false
        default: "false"
  push:
    branches: [main]
    tags:
      - "v*"
      - "m*"

jobs:
  build-and-gate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      AWS_REGION: us-east-1
      ECR_REPO: jobintel
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release tag
        run: |
          set -euo pipefail
          tag="${{ github.event.inputs.image_tag }}"
          if [ -z "$tag" ]; then
            tag="${GITHUB_SHA}"
          fi
          echo "IMAGE_TAG=$tag" >> "$GITHUB_ENV"

      - name: Resolve release mode (kind/tier)
        run: |
          set -euo pipefail
          release_kind="${{ github.event.inputs.release_kind || '' }}"
          release_tier="${{ github.event.inputs.release_tier || '' }}"
          semver_level_input="${{ github.event.inputs.semver_level || 'auto' }}"
          major_override="${{ github.event.inputs.major || 'false' }}"
          release_tag="${IMAGE_TAG}"

          if [ -z "${release_tier}" ] || [ "${release_tier}" = "auto" ]; then
            release_tier="${semver_level_input}"
          fi

          if [ "${GITHUB_EVENT_NAME}" = "push" ] && [ "${GITHUB_REF_TYPE}" = "tag" ]; then
            release_tag="${GITHUB_REF_NAME}"
            if [[ "${GITHUB_REF_NAME}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              release_kind="product"
              curr_major="${BASH_REMATCH[1]}"
              curr_minor="${BASH_REMATCH[2]}"
              curr_patch="${BASH_REMATCH[3]}"
              previous_tag="$(git tag -l 'v*' --sort=v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | grep -Fvx "${GITHUB_REF_NAME}" | tail -n 1 || true)"
              if [ -n "${previous_tag}" ] && [[ "${previous_tag}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                prev_major="${BASH_REMATCH[1]}"
                prev_minor="${BASH_REMATCH[2]}"
                prev_patch="${BASH_REMATCH[3]}"
                if [ "${curr_major}" -gt "${prev_major}" ]; then
                  release_tier="major"
                elif [ "${curr_minor}" -gt "${prev_minor}" ]; then
                  release_tier="minor"
                elif [ "${curr_patch}" -gt "${prev_patch}" ]; then
                  release_tier="patch"
                fi
              fi
            elif [[ "${GITHUB_REF_NAME}" =~ ^m[0-9]+- ]]; then
              release_kind="milestone"
            fi
          fi

          if [ "${major_override}" = "true" ]; then
            release_tier="major"
          fi

          if [ -z "${release_kind}" ]; then
            release_kind="product"
          fi
          if [ -z "${release_tier}" ]; then
            release_tier="minor"
          fi

          echo "RELEASE_KIND=${release_kind}" >> "$GITHUB_ENV"
          echo "RELEASE_TIER=${release_tier}" >> "$GITHUB_ENV"
          echo "RELEASE_TAG=${release_tag}" >> "$GITHUB_ENV"
          echo "release_kind=${release_kind}"
          echo "release_tier=${release_tier}"
          echo "release_tag=${release_tag}"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Docker setup (QEMU + Buildx)
        uses: docker/setup-qemu-action@v3

      - name: Buildx builder
        uses: docker/setup-buildx-action@v3

      - name: Render release notes template
        run: |
          set -euo pipefail
          IMAGE_REF_PLACEHOLDER="000000000000.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}@sha256:0000000000000000000000000000000000000000000000000000000000000000"
          notes_path="/tmp/release-notes-${IMAGE_TAG}.md"
          python3 scripts/release/render_release_notes.py \
            --release-kind "${RELEASE_KIND}" \
            --semver-level "${RELEASE_TIER}" \
            --tag "${RELEASE_TAG}" \
            --main-sha "${GITHUB_SHA}" \
            --image-ref "${IMAGE_REF_PLACEHOLDER}" \
            --arch amd64 \
            --arch arm64 \
            --out "${notes_path}"
          echo "RELEASE_NOTES_PATH=${notes_path}" >> "$GITHUB_ENV"

      - name: Validate release notes template mode
        run: |
          set -euo pipefail
          python3 scripts/release/validate_release_body.py \
            --release-kind "${RELEASE_KIND}" \
            --semver-level "${RELEASE_TIER}" \
            --tag "${RELEASE_TAG}" \
            --body-file "${RELEASE_NOTES_PATH}"

      - name: Publish image to ECR (multi-arch)
        run: |
          set -euo pipefail
          IMAGE_TAG="$IMAGE_TAG" \
          AWS_REGION="$AWS_REGION" \
          ECR_REPO="$ECR_REPO" \
          RELEASE_METADATA_PATH="ops/proof/releases/release-${IMAGE_TAG}.json" \
            scripts/release/build_and_push_ecr.sh

      - name: Inject CI evidence into release metadata (M19A)
        run: |
          set -euo pipefail
          metadata="ops/proof/releases/release-${IMAGE_TAG}.json"
          python3 - "$metadata" "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" "${{ github.run_id }}" "${{ github.workflow }}" <<'PY'
          import json
          import sys
          from pathlib import Path
          path = Path(sys.argv[1])
          ci_run_url = sys.argv[2]
          ci_run_id = sys.argv[3]
          ci_workflow = sys.argv[4]
          doc = json.loads(path.read_text(encoding="utf-8"))
          doc["ci_run_url"] = ci_run_url
          doc["ci_run_id"] = ci_run_id
          doc["ci_workflow"] = ci_workflow
          path.write_text(json.dumps(doc, indent=2, sort_keys=True) + "\n", encoding="utf-8")
          print(f"injected ci_run_url={ci_run_url}")
          PY

      - name: Verify release metadata generated and valid
        run: |
          set -euo pipefail
          metadata="ops/proof/releases/release-${IMAGE_TAG}.json"
          test -s "$metadata"
          python3 - "$metadata" <<'PY'
          import json
          import re
          import sys

          path = sys.argv[1]
          doc = json.load(open(path, "r", encoding="utf-8"))
          required = [
              "git_sha",
              "image_repo",
              "image_tag",
              "image_digest",
              "build_timestamp",
              "supported_architectures",
              "image_ref_digest",
          ]
          missing = [k for k in required if k not in doc]
          if missing:
              raise SystemExit(f"missing metadata keys: {missing}")
          if not isinstance(doc.get("supported_architectures"), list) or not doc["supported_architectures"]:
              raise SystemExit("supported_architectures must be a non-empty list")
          image_ref = str(doc.get("image_ref_digest", "")).strip()
          if not re.match(r"^\d+\.dkr\.ecr\.[^.]+\.amazonaws\.com\/[A-Za-z0-9._\/-]+@sha256:[0-9a-f]{64}$", image_ref):
              raise SystemExit(f"invalid image_ref_digest format: {image_ref}")
          print(f"metadata_ok image_ref_digest={image_ref}")
          PY
          python3 scripts/release/check_release_proof_bundle.py "$metadata" --require-ci-evidence

      - name: Verify manifest includes amd64 + arm64
        run: |
          set -euo pipefail
          account_id="$(aws sts get-caller-identity --query Account --output text)"
          image_ref="${account_id}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${IMAGE_TAG}"
          scripts/release/verify_ecr_image_arch.py --image-ref "$image_ref" --require-arch amd64 --require-arch arm64

      - name: DR arm64 workload precheck (image mismatch gate)
        run: |
          set -euo pipefail
          metadata="ops/proof/releases/release-${IMAGE_TAG}.json"
          image_ref="$(python3 - "$metadata" <<'PY'
          import json
          import sys

          print(json.load(open(sys.argv[1], "r", encoding="utf-8"))["image_ref_digest"])
          PY
          )"
          CHECK_IMAGE_ONLY=1 CHECK_ARCH=arm64 IMAGE_REF="$image_ref" scripts/ops/dr_validate.sh

      - name: Validate release body (pre-publish)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release == 'true' }}
        env:
          RELEASE_KIND_INPUT: ${{ github.event.inputs.release_kind }}
          RELEASE_TIER_INPUT: ${{ github.event.inputs.release_tier }}
          SEMVER_LEVEL_INPUT: ${{ github.event.inputs.semver_level }}
          MAJOR_INPUT: ${{ github.event.inputs.major }}
          RELEASE_TAG_INPUT: ${{ github.event.inputs.release_tag }}
          RELEASE_BODY_INPUT: ${{ github.event.inputs.release_body }}
          DEV_MODE_INPUT: ${{ github.event.inputs.dev_mode }}
        run: |
          set -euo pipefail
          release_tag="$RELEASE_TAG_INPUT"
          if [ -z "$release_tag" ]; then
            release_tag="$IMAGE_TAG"
          fi
          release_kind="$RELEASE_KIND_INPUT"
          if [ -z "$release_kind" ]; then
            if [[ "$release_tag" == v* ]]; then
              release_kind="product"
            elif [[ "$release_tag" == m* ]]; then
              release_kind="milestone"
            else
              echo "release_kind is required when release_tag does not start with 'v' or 'm'" >&2
              exit 1
            fi
          fi

          if [ -z "$RELEASE_BODY_INPUT" ]; then
            echo "release_body is required when publish_release=true" >&2
            exit 1
          fi

          semver_level="$SEMVER_LEVEL_INPUT"
          if [ -z "$semver_level" ] || [ "$semver_level" = "auto" ]; then
            semver_level="$RELEASE_TIER_INPUT"
          fi
          if [ -z "$semver_level" ] || [ "$semver_level" = "auto" ]; then
            semver_level="auto"
          fi
          if [ "$MAJOR_INPUT" = "true" ]; then
            semver_level="major"
          fi

          printf "%s\n" "$RELEASE_BODY_INPUT" > /tmp/release-body.md
          validate_args=( \
            --release-kind "$release_kind" \
            --semver-level "$semver_level" \
            --tag "$release_tag" \
            --body-file /tmp/release-body.md \
            --require-ci-evidence \
          )
          if [[ "$DEV_MODE_INPUT" == "true" ]]; then
            validate_args+=( --dev-mode )
          fi
          python3 scripts/release/validate_release_body.py "${validate_args[@]}"
          echo "RELEASE_TAG=$release_tag" >> "$GITHUB_ENV"

      - name: Publish GitHub release
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TITLE_INPUT: ${{ github.event.inputs.release_title }}
          RELEASE_BODY_INPUT: ${{ github.event.inputs.release_body }}
        run: |
          set -euo pipefail
          release_title="$RELEASE_TITLE_INPUT"
          if [ -z "$release_title" ]; then
            release_title="SignalCraft ${RELEASE_TAG}"
          fi
          gh release create "$RELEASE_TAG" --title "$release_title" --notes "$RELEASE_BODY_INPUT"

      - name: Upload release metadata
        uses: actions/upload-artifact@v4
        with:
          name: release-metadata-${{ env.IMAGE_TAG }}
          path: ops/proof/releases/release-${{ env.IMAGE_TAG }}.json
          retention-days: 14
